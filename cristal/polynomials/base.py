"""
Base classes for polynomial representations (:class:`BasePolynomialFamily`)
and for multivariate polynomial basis generation (:class:`MultivariatePolynomialBasis`).
"""

from abc import ABC, abstractmethod
from multiprocessing import Pool

import numpy as np


class BasePolynomialFamily(ABC):
    """Base class for polynomial families."""

    @staticmethod
    @abstractmethod
    def apply(x: np.ndarray, multidegree_combinations: np.ndarray) -> np.ndarray:
        """Apply the polynomial basis function to the input data.

        Parameters
        ----------
        x : np.ndarray (1, d) or (d,)
            The input data.
        multidegree_combinations : np.ndarray (s(n), d)
            The multidegree combinations. Should be of shape (s(n), d)
            where s(n) is the number of combinations and d is the dimension of the input data.

        Returns
        -------
        np.ndarray (s(n), d)
            The transformed input data.

        Example
        -------

        .. code-block:: python

            BasePolynomialFamily.apply(np.array([2, 7]), np.array([[0, 0], [1, 0], [0, 1]]))
            array([[U_0(2), U_0(7)],
                [U_1(2), U_0(7)],
                [U_0(2), U_1(7)]])
        """


class MultivariatePolynomialBasis:
    """Class for generating polynomial combinations and applying polynomial basis functions."""

    @staticmethod
    def generate_multidegree_combinations(max_degree: int, dimensions: int) -> np.ndarray:
        """Generate degree combinations for each dimension up to a specified maximum degree.

        Parameters
        ----------
        max_degree : int
            The maximum degree of the monomials.
        dimensions : int
            The number of dimensions.

        Returns
        -------
        np.ndarray (s(n), d)
            An array of shape (s(n), d) containing the multidegree combinations,
            where s(n) is the number of combinations and d is the number of `dimensions`.

        Example
        -------

        .. code-block:: python

            MultivariatePolynomialBasis.generate_multidegree_combinations(2, 3)
            array([[0, 0, 0],
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1],
            [2, 0, 0],
            [1, 1, 0],
            [1, 0, 1],
            [0, 2, 0],
            [0, 1, 1],
            [0, 0, 2]], dtype=int8)
        """

        def helper(remaining_dimensions, remaining_degree, combination):
            if remaining_dimensions == 0:
                combinations.append(combination)
                return
            for value in range(0, remaining_degree + 1):
                helper(remaining_dimensions - 1, remaining_degree - value, combination + [value])

        combinations = []
        helper(dimensions, max_degree, [])
        return np.asarray(sorted(combinations, key=lambda e: (np.sum(list(e)), list(-1 * np.array(list(e))))), dtype=np.int8)

    @staticmethod
    def apply_polynomial_family(x: np.ndarray, multidegree_combinations: np.ndarray, polynomial_family: type[BasePolynomialFamily]) -> np.ndarray:
        """Applies the polynomial basis to the input data.

        Parameters
        ----------
        x : np.ndarray (1, d) or (d,)
            The input data to transform.
        multidegree_combinations : np.ndarray (s(n), d)
            The multidegree combinations matrix generated by :func:`generate_multidegree_combinations`.
        polynomial_family : type[BasePolynomialFamily]
            The BasePolynomialFamily class to apply.

        Returns
        -------
        np.ndarray (s(n), 1)
            The transformed data.

        Example
        -------

        .. code-block:: python

            MultivariatePolynomialBasis.apply_polynomial_family(np.array([2, 7]), np.array([[0, 0], [1, 0], [0, 1]]), BasePolynomialFamily)
            array([[U_0(2)*U_0(7)],
            [U_1(2)*U_0(7)],
            [U_0(2)*U_1(7)]])
        """
        result = polynomial_family.apply(x, multidegree_combinations)
        return np.prod(result, axis=1).reshape(-1, 1)

    @staticmethod
    def make_design_matrix(
        x: np.ndarray, multidegree_combinations: np.ndarray, polynomial_family: type[BasePolynomialFamily], allow_parallelization: bool = False
    ) -> np.ndarray:
        """Compute the design matrix for the given data points and monomials.
        If s(n) > 500 and N > 1000, it will use a parallelized approach to compute the design matrix.

        Parameters
        ----------
        x : np.ndarray (N, d)
            The input data to transform.
        multidegree_combinations : np.ndarray (s(n), d)
            The multidegree combinations matrix generated by :func:`generate_multidegree_combinations`.
        polynomial_family : type[BasePolynomialFamily]
            The BasePolynomialFamily class to apply.
        allow_parallelization : bool, optional
            Whether to allow parallelization, by default False

        Returns
        -------
        np.ndarray (N, s(n))
            The design matrix for the given data points and multidegree combinations.

        Example
        -------

        .. code-block:: python

            x = np.array([[2, 7], [4, 5]])
            MultivariatePolynomialBasis.make_design_matrix(x, np.array([[0, 0], [1, 0], [0, 1]]), BasePolynomialFamily)
            array([[U_0(2)*U_0(7), U_1(2)*U_0(7), U_0(2)*U_1(7)],
                [U_0(4)*U_0(5), U_1(4)*U_0(5), U_0(4)*U_1(5)]])
        """

        def compute_row(xx):
            return MultivariatePolynomialBasis.apply_polynomial_family(xx, multidegree_combinations, polynomial_family)[:, 0]

        if allow_parallelization and x.shape[0] > 1000 and multidegree_combinations.shape[0] > 500:
            with Pool() as pool:
                results = pool.map(compute_row, x)
            X = np.array(results)
        else:
            X = np.empty((x.shape[0], multidegree_combinations.shape[0]), dtype=x.dtype)
            for idx, xx in enumerate(x):
                X[idx] = compute_row(xx)
        return X
